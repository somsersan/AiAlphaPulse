"""Telegram –±–æ—Ç –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –Ω–æ–≤–æ—Å—Ç–µ–π"""
import os
import json
from datetime import datetime, timedelta
from typing import List, Dict
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from dotenv import load_dotenv

from ..database import get_db_cursor
from .news_analyzer import NewsAnalyzer

load_dotenv()


class NewsBot:
    """Telegram –±–æ—Ç –¥–ª—è –Ω–æ–≤–æ—Å—Ç–µ–π"""
    
    def __init__(self):
        self.token = os.getenv('TELEGRAM_BOT_TOKEN')
        if not self.token:
            raise ValueError("TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ .env")
        
        self.analyzer = NewsAnalyzer()
        self.app = Application.builder().token(self.token).build()
        
        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã
        self.app.add_handler(CommandHandler("start", self.start_command))
        self.app.add_handler(CommandHandler("help", self.help_command))
        self.app.add_handler(CommandHandler("top", self.top_command))
        self.app.add_handler(CallbackQueryHandler(self.button_callback))
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /start"""
        welcome_message = """
üî• *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ AiAlphaPulse!*

–Ø –ø–æ–º–æ–≥—É –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å —Å–∞–º—ã–µ –≥–æ—Ä—è—á–∏–µ —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–µ –Ω–æ–≤–æ—Å—Ç–∏.

üìä *–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:*
/top - –¢–æ–ø –Ω–æ–≤–æ—Å—Ç–µ–π (—Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏)
/help - –°–ø—Ä–∞–≤–∫–∞

üìå *–ü—Ä–∏–º–µ—Ä—ã:*
`/top 10 24` - –¢–æ–ø-10 –∑–∞ 24 —á–∞—Å–∞
`/top 5 48` - –¢–æ–ø-5 –∑–∞ 48 —á–∞—Å–æ–≤
`/top` - –¢–æ–ø-10 –∑–∞ 24 —á–∞—Å–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)

üîî *–ê–≤—Ç–æ—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:*
–ì–æ—Ä—è—á–∏–µ –Ω–æ–≤–æ—Å—Ç–∏ (hotness ‚â• 0.7) –ø—Ä–∏—Ö–æ–¥—è—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏!
        """
        await update.message.reply_text(welcome_message, parse_mode='Markdown')
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /help"""
        help_text = """
üìñ *–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º*

*–§–æ—Ä–º–∞—Ç:* `/top [–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ] [—á–∞—Å—ã]`

*–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:*
‚Ä¢ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ - —Å–∫–æ–ª—å–∫–æ –Ω–æ–≤–æ—Å—Ç–µ–π (1-20, default: 10)
‚Ä¢ —á–∞—Å—ã - –∑–∞ –∫–∞–∫–æ–π –ø–µ—Ä–∏–æ–¥ (1-168, default: 24)

*–ü—Ä–∏–º–µ—Ä—ã:*
`/top` - –¢–æ–ø-10 –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞
`/top 5` - –¢–æ–ø-5 –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞  
`/top 15 48` - –¢–æ–ø-15 –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 48 —á–∞—Å–æ–≤
`/top 20 72` - –¢–æ–ø-20 –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 3 –¥–Ω—è

üìä *–ß—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è:*
‚Ä¢ –ó–∞–≥–æ–ª–æ–≤–æ–∫ –Ω–æ–≤–æ—Å—Ç–∏
‚Ä¢ –û—Ü–µ–Ω–∫–∞ –≥–æ—Ä—è—á–µ—Å—Ç–∏ (0-1)
‚Ä¢ –ü–æ—á–µ–º—É –≤–∞–∂–Ω–æ —Å–µ–π—á–∞—Å
‚Ä¢ –¢–∏–∫–µ—Ä—ã/–∞–∫—Ç–∏–≤—ã
‚Ä¢ –°—Å—ã–ª–∫–∏ –Ω–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∏
‚Ä¢ –í—Ä–µ–º–µ–Ω–Ω–∞—è —à–∫–∞–ª–∞
‚Ä¢ –ß–µ—Ä–Ω–æ–≤–∏–∫ –∞–Ω–∞–ª–∏–∑–∞

üî• *–î–ª—è –æ—Å–æ–±–æ –≥–æ—Ä—è—á–∏—Ö –Ω–æ–≤–æ—Å—Ç–µ–π* (‚â•0.7):
‚Ä¢ –¢–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª
‚Ä¢ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –∞–∫—Ç–∏–≤–∞–º
        """
        await update.message.reply_text(help_text, parse_mode='Markdown')
    
    async def top_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /top [limit] [hours]"""
        # –ü–∞—Ä—Å–∏–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã
        args = context.args
        limit = 10
        hours = 24
        
        try:
            if len(args) >= 1:
                limit = min(max(int(args[0]), 1), 20)
            if len(args) >= 2:
                hours = min(max(int(args[1]), 1), 168)
        except ValueError:
            await update.message.reply_text(
                "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /top [–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ] [—á–∞—Å—ã]"
            )
            return
        
        await update.message.reply_text(
            f"üîç –ü–æ–ª—É—á–∞—é —Ç–æ–ø-{limit} –Ω–æ–≤–æ—Å—Ç–µ–π –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ {hours}—á..."
        )
        
        # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤–æ—Å—Ç–∏ –∏–∑ –ë–î
        news_list = self.get_top_news(limit, hours)
        
        if not news_list:
            await update.message.reply_text(
                f"üì≠ –ù–µ—Ç –Ω–æ–≤–æ—Å—Ç–µ–π –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ {hours} —á–∞—Å–æ–≤"
            )
            return
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–∞–∂–¥—É—é –Ω–æ–≤–æ—Å—Ç—å
        for i, news in enumerate(news_list, 1):
            message = self.format_news_message(news, i, len(news_list))
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
            keyboard = [[
                InlineKeyboardButton(
                    "üìä –î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑", 
                    callback_data=f"analyze_{news['id']}"
                )
            ]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                message,
                parse_mode='Markdown',
                reply_markup=reply_markup,
                disable_web_page_preview=True
            )
    
    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ –∫–Ω–æ–ø–∫–∏"""
        query = update.callback_query
        await query.answer()
        
        if query.data.startswith("analyze_"):
            news_id = int(query.data.split("_")[1])
            
            await query.edit_message_text("‚è≥ –ì–µ–Ω–µ—Ä–∏—Ä—É—é –¥–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑...")
            
            # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤–æ—Å—Ç—å –∏–∑ –ë–î
            news = self.get_news_by_id(news_id)
            if not news:
                await query.edit_message_text("‚ùå –ù–æ–≤–æ—Å—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
                return
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∞–Ω–∞–ª–∏–∑ —á–µ—Ä–µ–∑ LLM
            analysis = self.analyzer.generate_full_analysis({
                'headline': news['headline'],
                'content': news['content'],
                'tickers': news['tickers'],
                'hotness': news['ai_hotness']
            })
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º
            detail_message = self.format_detailed_analysis(news, analysis)
            await query.edit_message_text(
                detail_message,
                parse_mode='Markdown',
                disable_web_page_preview=True
            )
    
    def get_top_news(self, limit: int, hours: int) -> List[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–æ–ø –Ω–æ–≤–æ—Å—Ç–µ–π –∏–∑ –ë–î"""
        time_threshold = datetime.now() - timedelta(hours=hours)
        
        with get_db_cursor() as cursor:
            cursor.execute("""
                SELECT 
                    lan.id,
                    lan.headline,
                    lan.content,
                    lan.ai_hotness,
                    lan.tickers_json,
                    lan.urls_json,
                    lan.published_time,
                    lan.id_cluster,
                    sc.first_time,
                    sc.last_time,
                    sc.doc_count
                FROM llm_analyzed_news lan
                JOIN story_clusters sc ON lan.id_cluster = sc.id
                WHERE lan.published_time >= %s
                ORDER BY lan.ai_hotness DESC, lan.published_time DESC
                LIMIT %s
            """, (time_threshold, limit))
            
            news_list = []
            for row in cursor.fetchall():
                news_list.append({
                    'id': row['id'],
                    'headline': row['headline'],
                    'content': row['content'],
                    'ai_hotness': row['ai_hotness'],
                    'tickers': json.loads(row['tickers_json']) if row['tickers_json'] else [],
                    'urls': json.loads(row['urls_json']) if row['urls_json'] else [],
                    'published_time': row['published_time'],
                    'first_time': row['first_time'],
                    'last_time': row['last_time'],
                    'doc_count': row['doc_count']
                })
            
            return news_list
    
    def get_news_by_id(self, news_id: int) -> Dict:
        """–ü–æ–ª—É—á–∏—Ç—å –Ω–æ–≤–æ—Å—Ç—å –ø–æ ID"""
        with get_db_cursor() as cursor:
            cursor.execute("""
                SELECT 
                    lan.id,
                    lan.headline,
                    lan.content,
                    lan.ai_hotness,
                    lan.tickers_json,
                    lan.urls_json,
                    lan.published_time
                FROM llm_analyzed_news lan
                WHERE lan.id = %s
            """, (news_id,))
            
            row = cursor.fetchone()
            if not row:
                return None
            
            return {
                'id': row['id'],
                'headline': row['headline'],
                'content': row['content'],
                'ai_hotness': row['ai_hotness'],
                'tickers': json.loads(row['tickers_json']) if row['tickers_json'] else [],
                'urls': json.loads(row['urls_json']) if row['urls_json'] else []
            }
    
    def format_news_message(self, news: Dict, index: int, total: int) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –Ω–æ–≤–æ—Å—Ç—å—é"""
        hotness = news['ai_hotness']
        hotness_emoji = self._get_hotness_emoji(hotness)
        
        # –¢–∏–∫–µ—Ä—ã
        tickers_str = ', '.join(news['tickers']) if news['tickers'] else '‚Äî'
        
        # –°—Å—ã–ª–∫–∏ (–º–∞–∫—Å 3)
        urls = news.get('urls', [])[:3]
        sources_str = '\n'.join([f"‚Ä¢ {url}" for url in urls]) if urls else '‚Äî'
        
        # Timeline
        first_time = news.get('first_time')
        last_time = news.get('last_time')
        timeline = f"–ü–µ—Ä–≤–æ–µ —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ: {first_time.strftime('%d.%m %H:%M')}"
        if first_time != last_time:
            timeline += f"\n–ü–æ—Å–ª–µ–¥–Ω–µ–µ: {last_time.strftime('%d.%m %H:%M')}"
        
        message = f"""
{hotness_emoji} *#{index}/{total} –ù–æ–≤–æ—Å—Ç—å*

*{news['headline']}*

üî• *Hotness:* {hotness:.2f}/1.00
üìä *–¢–∏–∫–µ—Ä—ã:* {tickers_str}
üìÑ *–î–æ–∫—É–º–µ–Ω—Ç–æ–≤:* {news.get('doc_count', 1)}

‚è∞ *Timeline:*
{timeline}

üîó *–ò—Å—Ç–æ—á–Ω–∏–∫–∏:*
{sources_str}
        """.strip()
        
        return message
    
    def format_detailed_analysis(self, news: Dict, analysis: Dict) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞"""
        hotness = news['ai_hotness']
        hotness_emoji = self._get_hotness_emoji(hotness)
        
        message = f"""
{hotness_emoji} *–î–ï–¢–ê–õ–¨–ù–´–ô –ê–ù–ê–õ–ò–ó*

*{news['headline']}*

üî• *Hotness:* {hotness:.2f}/1.00

üí° *–ü–æ—á–µ–º—É –≤–∞–∂–Ω–æ —Å–µ–π—á–∞—Å:*
{analysis.get('why_now', '–ê–Ω–∞–ª–∏–∑ —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è...')}

üìù *–ß–µ—Ä–Ω–æ–≤–∏–∫ –∞–Ω–∞–ª–∏–∑–∞:*
{analysis.get('draft', '–î–µ—Ç–∞–ª–∏ —Ñ–æ—Ä–º–∏—Ä—É—é—Ç—Å—è...')}
        """.strip()
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª –¥–ª—è –≥–æ—Ä—è—á–∏—Ö –Ω–æ–≤–æ—Å—Ç–µ–π
        if hotness >= 0.7 and 'trading_signal' in analysis:
            message += f"\n\nüéØ *–¢–û–†–ì–û–í–´–ô –°–ò–ì–ù–ê–õ:*\n{analysis['trading_signal']}"
        
        return message
    
    def _get_hotness_emoji(self, hotness: float) -> str:
        """–≠–º–æ–¥–∑–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≥–æ—Ä—è—á–Ω–æ—Å—Ç–∏"""
        if hotness >= 0.8:
            return "üî¥üî•"
        elif hotness >= 0.6:
            return "üü†üî•"
        elif hotness >= 0.4:
            return "üü°"
        else:
            return "üü¢"
    
    def run(self):
        """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        print("ü§ñ Telegram –±–æ—Ç –∑–∞–ø—É—â–µ–Ω...")
        self.app.run_polling(allowed_updates=Update.ALL_TYPES)

