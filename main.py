from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
from contextlib import asynccontextmanager
import asyncio
import threading
import time
from datetime import datetime
import uvicorn
from rss_parser import parse_and_save_rss, check_articles, get_articles_stats, setup_database

# Lifespan event handler
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    print("üöÄ –ó–∞–ø—É—Å–∫ RSS Parser API...")
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    try:
        setup_database()
        print("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {e}")
    
    # –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–¥–∞—á–∏ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    thread = threading.Thread(target=auto_parse_worker, daemon=True)
    thread.start()
    print("üîÑ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–∞—Ä—Å–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω (–∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É)")
    
    yield
    
    # Shutdown (if needed)
    print("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ RSS Parser API...")

# –°–æ–∑–¥–∞–µ–º FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
app = FastAPI(
    title="RSS Parser API",
    description="API –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ RSS-–ª–µ–Ω—Ç —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É",
    version="1.0.0",
    lifespan=lifespan
)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic –º–æ–¥–µ–ª–∏ –¥–ª—è API
class ArticleResponse(BaseModel):
    id: int
    source: str
    title: str
    author: Optional[str]
    category: Optional[str]
    published: Optional[str]
    created_at: str
    word_count: int
    reading_time: int
    is_processed: bool
    link: str
    image_url: Optional[str]
    summary: Optional[str]
    content: Optional[str]

class StatsResponse(BaseModel):
    total_articles: int
    processed_articles: int
    avg_words: float
    sources: List[dict]

class ParseResponse(BaseModel):
    message: str
    new_articles_count: int
    timestamp: str

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞
parsing_status = {
    "is_running": False,
    "last_run": None,
    "last_articles_count": 0
}

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞
def auto_parse_worker():
    """–§–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É."""
    global parsing_status
    
    while True:
        try:
            print(f"üîÑ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–∞—Ä—Å–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω –≤ {datetime.now()}")
            parsing_status["is_running"] = True
            
            new_count = parse_and_save_rss()
            parsing_status["last_run"] = datetime.now()
            parsing_status["last_articles_count"] = new_count
            parsing_status["is_running"] = False
            
            print(f"‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–∞—Ä—Å–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω. –î–æ–±–∞–≤–ª–µ–Ω–æ —Å—Ç–∞—Ç–µ–π: {new_count}")
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –≤ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–º –ø–∞—Ä—Å–∏–Ω–≥–µ: {e}")
            parsing_status["is_running"] = False
        
        # –ñ–¥–µ–º 60 —Å–µ–∫—É–Ω–¥ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –ø–∞—Ä—Å–∏–Ω–≥–æ–º
        time.sleep(60)


# API —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã
@app.get("/", response_model=dict)
async def root():
    """–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ API."""
    return {
        "message": "RSS Parser API",
        "version": "1.0.0",
        "status": "running",
        "auto_parsing": "enabled (every minute)"
    }

@app.get("/health")
async def health_check():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è."""
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "parsing_status": parsing_status
    }

@app.post("/parse", response_model=ParseResponse)
async def manual_parse():
    """–†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ –ø–∞—Ä—Å–∏–Ω–≥–∞ RSS-–ª–µ–Ω—Ç."""
    try:
        print("üîÑ –†—É—á–Ω–æ–π –ø–∞—Ä—Å–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω")
        new_count = parse_and_save_rss()
        
        return ParseResponse(
            message="–ü–∞—Ä—Å–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ",
            new_articles_count=new_count,
            timestamp=datetime.now().isoformat()
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: {str(e)}")

@app.get("/articles", response_model=List[ArticleResponse])
async def get_articles(limit: int = 10):
    """–ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å—Ç–∞—Ç—å–∏."""
    try:
        articles = check_articles(limit)
        return [ArticleResponse(**article) for article in articles]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–µ–π: {str(e)}")

@app.get("/stats", response_model=StatsResponse)
async def get_stats():
    """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —Å—Ç–∞—Ç—å—è–º."""
    try:
        stats = get_articles_stats()
        return StatsResponse(**stats)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {str(e)}")

@app.get("/status")
async def get_parsing_status():
    """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞."""
    return {
        "is_running": parsing_status["is_running"],
        "last_run": parsing_status["last_run"].isoformat() if parsing_status["last_run"] else None,
        "last_articles_count": parsing_status["last_articles_count"]
    }

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True
    )
